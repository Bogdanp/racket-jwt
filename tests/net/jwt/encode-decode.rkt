#lang typed/racket

(require typed/rackunit typed/json
         net/jwt/encode-decode
         net/jwt/structs
         net/jwt/misc
         net/jwt/base64
         net/jwt/algorithms
         option-bind)

(define-type JWTHeader (HashTable Symbol JSExpr))

(check-false
 (decode-jwt
  "eyJhbGciOiJIUzI1NiIsImtpZCI6IjhlN2EwMGYxZGFmMWMyYjcwMTU0NTlkZDY4Njg1NmMyIn0")
 "simple decode failure check")

;;;;; A simple JWT like the default one produced by jwt.io:
; Header
(define jwt1-raw-header "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9")
(: jwt1-header JWTHeader)
(define jwt1-header
  (for/hasheq : JWTHeader ([k '(alg     typ)]
                                           [v '("HS256" "JWT")])
    (values k v)))

; Claims
(define jwt1-raw-payload
  "eyJzdWIiOjEyMzQ1Njc4OTAsIm5hbWUiOiJKb2huIERvZSIsImFkbWluIjp0cnVlfQ")
(: jwt1-claims JWTClaimsSet)
(define jwt1-claims
  (JWTClaimsSet #f "1234567890" '() #f #f #f #f
                (for/hasheq : JWTHeader ([k '(name admin)]
                                         [v '("John Doe"
                                              #t)])
                  (values k v))))

; Sig
(define jwt1-signature "eoaDVGTClRdfxUZXiPs3f8FmJDkDE_VCQFXqKxpLsts")

(: jwt1 String)
(define jwt1 (.join jwt1-raw-header jwt1-raw-payload jwt1-signature))

;;;;; A second sample JWT (generated by jwt.io), with signature

; Header
(define jwt2-raw-header
  "eyJhbGciOiJIUzI1NiIsImtpZCI6IjhlN2EwMGYxZGFmMWMyYjcwMTU0NTlkZDY4Njg1NmMyIn0")
(define jwt2-header
  (for/hasheq : JWTHeader
    ([k '(alg     kid)]
     [v '("HS256" "8e7a00f1daf1c2b7015459dd686856c2")])
    (values k v)))

; Claims
(define jwt2-raw-payload
  (string-append "eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMTIzNDEyMzU0"
                 "MzcyNjUyMzQ4MTIzOTY0NTMyMzE0MzY1NDY3ODkyMyIsImF1ZCI6IjEyMzQ1"
                 "Njc4OS5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsImV4cCI6MjAwMDAw"
                 "MDAwMDAwMCwiaWF0IjoxNDIxMzczMjIyLCJlbWFpbCI6ImpvcmRhbkBleGFt"
                 "cGxlLmNvbSIsImF0X2hhc2giOiJ6eGN2NzZycXdlcnJ3ZmQxMjM2NTM0NiIs"
                 "ImF6cCI6IjEyMzQ1Njc4OS5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIs"
                 "ImVtYWlsX3ZlcmlmaWVkIjp0cnVlfQ"))
(define jwt2-exp-time 2000000000000) ; expiration on 23 Jun 65347.
(define jwt2-claims : JWTClaimsSet
  (JWTClaimsSet "accounts.google.com" ; iss
                "1234123543726523481239645323143654678923" ; sub, user ID
                '("123456789.apps.googleusercontent.com") ; aud
                (seconds->date jwt2-exp-time) ; FIXME before 23 Jun 65347
                #f ; no nbf
                (seconds->date 1421373222) ; iat, integer token issue time, req'd
                #f ; no jti        
                (for/hasheq : JWTHeader
                  ([k '(email   ; user email address; do not use as a PK
                        at_hash ; access token hash
                        azp     ; client_id of the auth'd presenter (if â‰  aud)
                        email_verified ; #t if email addr has been verified
                        )]
                   [v '("jordan@example.com" ; email
                        "zxcv76rqwerrwfd12365346" ; AT hash
                        "123456789.apps.googleusercontent.com" ; azp
                        #t)])
                  (values k v))))

(define jwt2-signature "jtWfuGLKabxOdhHjbYTXRnZ-ppka96RTymmSXr5w8D8")

(: jwt2 String)
(define jwt2 (.join jwt2-raw-header jwt2-raw-payload jwt2-signature))
(define jwt2-secret "secret")

(define verified-jwt2 : VerifiedJWT
  (verified-jwt jwt2-header jwt2-raw-header
                jwt2-claims jwt2-raw-payload
                jwt2-signature))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Decoding
(check-equal? (decode-jwt jwt1)
              (decoded-jwt jwt1-header jwt1-raw-header jwt1-claims
                           jwt1-raw-payload jwt1-signature)
              "decoding #1")
(check-equal? (decode-jwt jwt2)
              (decoded-jwt jwt2-header jwt2-raw-header jwt2-claims
                           jwt2-raw-payload jwt2-signature)
              "decoding #2")
;; Decoding then verifying
(check-equal? (?<- (lambda ([x : JWT]) (verify-jwt x "HS256" "secret"))
                   (decode-jwt jwt1))
              (verified-jwt jwt1-header jwt1-raw-header
                            jwt1-claims jwt1-raw-payload
                            jwt1-signature)
              "decode & verify #1")
(check-equal? (?<- (lambda ([x : JWT]) (verify-jwt x "HS256" "secret"))
                   (decode-jwt jwt2))
              verified-jwt2
              "decode & verify #2")
(check-false (?<- (lambda ([x : JWT]) (verify-jwt x "HS256" "not the secret"))
                  (decode-jwt jwt2))
             "decode & fail verification (wrong secret)")

;; decode/verify, no claim checks
(check-equal? (decode/verify jwt1 "HS256" "secret")
              (verified-jwt jwt1-header jwt1-raw-header
                            jwt1-claims jwt1-raw-payload
                            jwt1-signature)
              "decode/verify w/o claim checks #1")
(check-equal? (decode/verify jwt2 "HS256" "secret")
              verified-jwt2
              "decode/verify w/o claim checks #2")

;; iss claim check
(check-false (decode/verify jwt2 "HS256" "secret" #:iss "wrong.example.com")
             "decode/verify with wrong iss")
(check-equal? (decode/verify jwt2 "HS256" "secret" #:iss "accounts.google.com")
              verified-jwt2
              "decode/verify with iss")
;; aud claim check
(check-false (decode/verify jwt2 "HS256" "secret" #:aud "nobody.example.com")
             "decode/verify with wrong aud")
(check-equal? (decode/verify jwt2 "HS256" "secret"
                             #:aud "123456789.apps.googleusercontent.com")
              verified-jwt2
              "decode/verify with aud")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sample JWT with iss and aud claims

(define jwt3-issuer "http://www.example.com/")
(define jwt3-audience "http://www.fellowhuman.com/")
(define jwt3-raw-header "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9")
(define jwt3-header : JWTHeader (hasheq 'alg "HS256" 'typ "JWT"))
(define jwt3-payload
  (string-append "eyJzdWIiOiJibGFoYmxhaCIsImlzcyI6Imh0dHA6Ly93d3cuZXhhbXBsZS5j"
                 "b20vIiwiYXVkIjoiaHR0cDovL3d3dy5mZWxsb3dodW1hbi5jb20vIn0"))
(define jwt3-signature "VX7DWRXIi0j459czia9r6MiwyvD5wMQfPQtpVU3RMSE")
(define jwt3-claims
  (JWTClaimsSet jwt3-issuer "blahblah"
                (list jwt3-audience)
                #f #f #f #f (hasheq)))
(define jwt3-raw (.join jwt3-raw-header jwt3-payload jwt3-signature))
(define jwt3-struct
  (verified-jwt jwt3-header jwt3-raw-header jwt3-claims jwt3-payload
                jwt3-signature))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; decode/verify, aud and iss checks

;; Decoding
(define jwt3 (decode-jwt jwt3-raw))
(check-equal? jwt3
              (decoded-jwt jwt3-header jwt3-raw-header
                           jwt3-claims jwt3-payload jwt3-signature)
              "decoding #3")


;; No aud/iss check
(check-equal? (decode/verify jwt3-raw "HS256" "secret") jwt3-struct
              "decode/verify #3")

;; aud/iss checks, separately and together
(check-equal? (decode/verify jwt3-raw "HS256" "secret" #:aud jwt3-audience)
              jwt3-struct
              "decode/verify #3 with aud")
(check-equal? (decode/verify jwt3-raw "HS256" "secret" #:iss jwt3-issuer)
              jwt3-struct
              "decode/verify #3 with iss")
(check-equal? (decode/verify jwt3-raw "HS256" "secret"
                             #:aud jwt3-audience
                             #:iss jwt3-issuer)
              jwt3-struct
              "decode/verify #3 with aud & iss")

;; fail aud/iss checks
(check-false (decode/verify jwt3-raw "HS256" "secret"
                            #:aud "http://www.evil.com/")
             "d/v #3, wrong aud")
(check-false (decode/verify jwt3-raw "HS256" "secret"
                            #:iss "http://www.google.com/")
             "d/v #3, wrong iss")
; 1 of 2 wrong
(check-false (decode/verify jwt3-raw "HS256" "secret"
                            #:aud "http://www.evil.com/"
                            #:iss jwt3-issuer)
             "d/v #3, wrong aud / right iss")
(check-false (decode/verify jwt3-raw "HS256" "secret"
                            #:aud jwt3-audience
                            #:iss "http://foo.bar.baz/")
             "d/v #3, right aud / wrong iss")
; both wrong
(check-false (decode/verify jwt3-raw "HS256" "secret"
                            #:aud "http://www.evil.com/"
                            #:iss "http://www.google.com/")
             "d/v #3, wrong aud & iss")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Encoding, signing

;;;;; Unsecured JWTs: ;;;;;

(define issue-date 1000000000)
(check-equal? (encode/sign "none" ""
                           #:iss "http://www.example.com/"
                           #:iat issue-date)
              (string-append (jsexpr->string64/utf-8 #hasheq((alg . "none")))
                             "."
                             (jsexpr->string64/utf-8
                              ;; XXX brittle: hash k/v order may break test
                              (hasheq 'iss "http://www.example.com/"
                                      'iat issue-date))
                             ".")
              "Unsecured: encode/sign with algorithm none")
;; Same example, written using encode-jwt:
(check-equal? (encode-jwt #:iss "http://www.example.com/"
                      #:iat issue-date)
              (string-append (jsexpr->string64/utf-8 #hasheq((alg . "none")))
                             "."
                             (jsexpr->string64/utf-8
                              ;; XXX brittle: hash k/v order may break test
                              (hasheq 'iss "http://www.example.com/"
                                      'iat issue-date))
                             ".")
              "Unsecured: encode-jwt with algorithm none")

;; Example unsecured JWS from Appendix A.5 of RFC7515:
(define A.5-claims
  #{#hasheq((http://example.com/is_root . #t)) :: JWTHeader})
(define A.5-headers #{#hasheq((alg . "none")) :: JWTHeader})
(define A.5-headers-string (jsexpr->string64/utf-8 A.5-headers))
(define A.5-issuer "joe")
(define A.5-exptime 1300819380)
(define A.5-claims-payload
  (jsexpr->string64/utf-8 (hash-set (hash-set A.5-claims 'exp A.5-exptime)
                                    'iss A.5-issuer)))

(check-equal? (encode/sign "none" ""
                           #:iss A.5-issuer
                           #:iat #f
                           #:exp A.5-exptime
                           #:other A.5-claims)
              (string-append A.5-headers-string "." A.5-claims-payload ".")
              "Unsecured: RFC7515 appx A.5 example")
;; Again, same example but using encode-jwt:
(check-equal? (encode-jwt #:iss "joe"
                          #:iat #f
                          #:exp 1300819380
                          #:other A.5-claims)
              (string-append A.5-headers-string "." A.5-claims-payload ".")
              "Unsecured: RFC7515 appx A.5 example with encode-jwt")

;; Encode then decode
(check-equal? (decode-jwt (encode/sign "none" ""
                                       #:extra-headers A.5-headers
                                       #:iss "http://www.example.com"
                                       #:iat issue-date))
              (let ([claims (JWTClaimsSet "http://www.example.com"
                                          #f '() #f #f
                                          (seconds->date issue-date)
                                          #f
                                          #hasheq())])
                (decoded-jwt A.5-headers
                             A.5-headers-string
                             claims
                             (jsexpr->string64/utf-8 (claims->jshash claims))
                             ""))
              "Unsecured: encode/sign then decode-jwt")
(check-false (decode/verify
              (encode/sign "none" ""
                           #:extra-headers #hasheq((test . "foo"))
                           #:iss "http://www.example.com"
                           #:iat issue-date)
                            "none"
                            "")
             "Unsecured: fail to decode/verify a JWT from encode/sign with alg \"none\"")

;;;;; Secured JWTs ;;;;;

#| Example JSON submitted at https://jwt.io :
{
  "alg": "HS256",
  "test": "foo"
}
{
  "iat": 1000000000,
  "iss": "http://www.example.com"
}
The constant defs below are our representation of the above JSON.
|#
(define hs256-header : JWTHeader
  #{#hasheq((alg . "HS256")) : JWTHeader})
(define hs256-header-str (jsexpr->string64/utf-8 hs256-header))

(define hs256-ext-header : JWTHeader (hash-set hs256-header 'test "foo"))
(define hs256-ext-header-str (jsexpr->string64/utf-8 hs256-ext-header))

(define hs256-claims
  (JWTClaimsSet "http://www.example.com" #f '() #f #f (seconds->date issue-date)
                #f #hasheq()))
(define hs256-claims-str (jsexpr->string64/utf-8 (claims->jshash hs256-claims)))

;; The JWT produced by https://jwt.io has the following parts:
(define hs256-jwtio-header "eyJhbGciOiJIUzI1NiIsInRlc3QiOiJmb28ifQ")
(define hs256-jwtio-claims "eyJpYXQiOjEwMDAwMDAwMDAsImlzcyI6Imh0dHA6Ly93d3cuZXhhbXBsZS5jb20ifQ")
(define hs256-jwtio-signature "6kb6EjXACGvehEbQKHhcCAUKDVvBKJKdotTKSMTAYuo")

;; Begin tests

;; HS256
(check-equal? hs256-ext-header-str hs256-jwtio-header
              "HS256 test: check that we're matching jwt.io's output")
(check-equal? hs256-claims-str hs256-jwtio-claims
              "HS256 test: check that we're matching jwt.io's output")
(check-equal? (base64-url-encode
               (hs256 "swordfish"
                      (string-append hs256-ext-header-str "." hs256-claims-str)))
              hs256-jwtio-signature
              "HS256 test: check that our signature matches jwt.io's output")

(check-equal? (decode/verify (encode/sign "HS256" "swordfish"
                                          #:extra-headers #hasheq((test . "foo"))
                                          #:iss "http://www.example.com"
                                          #:iat issue-date)
                             "HS256" "swordfish")
              (verified-jwt hs256-ext-header hs256-ext-header-str
                            hs256-claims hs256-claims-str
                            hs256-jwtio-signature)
              "HS256 test: decode/verify secured JWT from encode/sign")

;; HS384
(define hs384-header : JWTHeader
  #{#hasheq((alg . "HS384")) : JWTHeader})
(define hs384-header-str (jsexpr->string64/utf-8 hs384-header))

(define hs384-ext-header : JWTHeader (hash-set hs384-header 'test "foo"))
(define hs384-ext-header-str (jsexpr->string64/utf-8 hs384-ext-header))

(define hs384-claims-str hs256-claims-str)

(define hs384-jwtio-signature
  "nDBGvSj7VyvhkVSrwQ1bqtrIACh9067phxS3OOUP08lT7_bj0QnFjKNBOKlpJ-BV")
(check-equal? (base64-url-encode
               (hs384 "swordfish"
                      (string-append hs384-ext-header-str "." hs384-claims-str)))
              hs384-jwtio-signature
              "HS384 test: check that our signature matches jwt.io's output")
(check-equal? (decode/verify (encode/sign "HS384" "swordfish"
                                          #:extra-headers #hasheq((test . "foo"))
                                          #:iss "http://www.example.com"
                                          #:iat issue-date)
                             "HS384" "swordfish")
              (verified-jwt hs384-ext-header hs384-ext-header-str
                            hs256-claims hs384-claims-str ; sic
                            hs384-jwtio-signature)
              "HS384 test: decode/verify secured JWT from encode/sign")

;; HS512
(define hs512-header : JWTHeader
  #{#hasheq((alg . "HS512")) : JWTHeader})
(define hs512-header-str (jsexpr->string64/utf-8 hs512-header))

(define hs512-ext-header : JWTHeader (hash-set hs512-header 'test "foo"))
(define hs512-ext-header-str (jsexpr->string64/utf-8 hs512-ext-header))

(define hs512-claims-str hs256-claims-str)

(define hs512-jwtio-signature
  "HkxGdAF2K8ADRgm1WUdFWKmZLm1EKzXKhcJ5FnD2YHFdILTZ4c1BDm7Kk-xMbXJfl0xuCHulATGzjo8YdlRTUA")

(check-equal? (base64-url-encode
               (hs512 "swordfish"
                      (string-append hs512-ext-header-str "." hs512-claims-str)))
              hs512-jwtio-signature
              "HS512 test: check that our signature matches jwt.io's output")
(check-equal? (decode/verify (encode/sign "HS512" "swordfish"
                                          #:extra-headers #hasheq((test . "foo"))
                                          #:iss "http://www.example.com"
                                          #:iat issue-date)
                             "HS512" "swordfish")
              (verified-jwt hs512-ext-header hs512-ext-header-str
                            hs256-claims hs512-claims-str ; sic
                            hs512-jwtio-signature)
              "HS512 test: decode/verify secured JWT from encode/sign")

;; exp check (border cases)
(define now-100 : Integer (- (current-seconds) 100))
(check-false (decode/verify (encode/sign "HS256" "xyzzy xyzzy"
                                          #:exp now-100
                                          #:iat #f)
                            "HS256" "xyzzy xyzzy"
                            #:clock-skew 99)
             "decode/verify exp failure edge case with #:clock-skew")
(check-equal? (decode/verify (encode/sign "HS256" "xyzzy xyzzy"
                                          #:exp now-100
                                          #:iat #f)
                            "HS256" "xyzzy xyzzy"
                            #:clock-skew 100)
              (let* ([claims (JWTClaimsSet #f #f '()
                                           (seconds->date now-100)
                                           #f #f #f
                                           (hasheq))]
                     [claims-str (jsexpr->string64/utf-8
                                  (claims->jshash claims))])
                (verified-jwt hs256-header hs256-header-str
                              claims claims-str
                              (base64-url-encode
                               (hs256 "xyzzy xyzzy"
                                      (string-append hs256-header-str "."
                                                     claims-str)))))
              "decode/verify exp success edge case with #:clock-skew")

;; nbf check (border cases)
(define now+100 : Integer (+ (current-seconds) 100))
(check-false (decode/verify (encode/sign "HS256" "xyzzy xyzzy"
                                          #:nbf now+100
                                          #:iat #f)
                            "HS256" "xyzzy xyzzy"
                            #:clock-skew 99)
             "decode/verify nbf failure edge case with #:clock-skew")
(check-equal? (decode/verify (encode/sign "HS256" "xyzzy xyzzy"
                                          #:nbf now+100
                                          #:iat #f)
                            "HS256" "xyzzy xyzzy"
                            #:clock-skew 100)
              (let* ([claims (JWTClaimsSet #f #f '() #f (seconds->date now+100)
                                           #f #f (hasheq))]
                     [claims-str
                      (jsexpr->string64/utf-8 (claims->jshash claims))])
                (verified-jwt hs256-header hs256-header-str
                              claims claims-str
                              (base64-url-encode
                               (hs256 "xyzzy xyzzy"
                                      (string-append hs256-header-str "."
                                                     claims-str)))))
              "decode/verify nbf success edge case with #:clock-skew")
